# -*- coding:utf-8 -*-
'''
@题目描述
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

@解题思路
顺时针打印的顺序就是先往右边走，然后依次是下左上。每个方向停止的条件是超出边界或者当前位置已经打印过了。

具体实现看代码，注释全。
'''
class Solution:
    # matrix类型为二维列表，需要返回列表
	def printMatrix(self, matrix):
		# write code here
		# 先计算二维矩阵的行列数
		row = len(matrix)
		col = len(matrix[0])
		# [0,1]就是往右走的x,y移动的距离，x不变，y+1，同样地写出下左上的移动方式
		dire = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 顺时针：右下左上
		res = [] # 打印结果存在res中，最后返回
		book = [[0] * col for i in range(row)] # 用于标记这个位置是否已经打印过了，初始化为0
		i = j = 0
		while 1:
			for k in range(4):
				flag = 0 #用于标记是否有进入while循环，若没有则表示所有结点都遍历过了，直接返回结果
				while i < row and j < col and book[i][j] == 0: #while的条件，不越界且当前位置未被遍历
					flag = 1
					res.append(matrix[i][j]) #打印
					book[i][j] = 1 #标记为已遍历
					i += dire[k][0] #更新下一步的取值
					j += dire[k][1]
				if flag == 0:
					return res
				#这两行比较重要，首先需要回退一步，因为当前位置越界或者已遍历了，需要回退
				#另外还需要更新下一步，且下一步的规则应该是(k+1) % 4。也就是如果当前是向右走的，接下来需要向下走。
				i = i - dire[k][0] + dire[(k+1) % 4][0]
				j = j - dire[k][1] + dire[(k+1) % 4][1]