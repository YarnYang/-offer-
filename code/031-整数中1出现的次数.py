# -*- coding:utf-8 -*-
'''
@题目描述
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

@解题思路
注释掉的部分用了很蠢的方法，就是计算逐个1-n中1的个数。说一下看了讨论区之后改进的方法。

就是就是一道数学题，找到规律之后抽象出来，写成代码，我们来一位位看。

- 个位，i=1
每10个数个位出现1次1，所以就把n/10看有几个10，那个位就出现了几个1，当不足10时，只要末尾>0，就+1，如52，有5个10，就出现了5次1，末尾2不足10，但是2>0，所以+1，抽象成公式：
n / (i*10) + n % (i*10) > 0 ? 1:0

- 十位，i=10
每100个数，十位就出现10个1，n / (i*10) * i。不足100，末尾<10就没有1，大于等于10且小于20，如19，就有19-9个1，大于等于20，就有10个1.抽象成公式：
为方便起见，我们令k = n % (i*10), 就是n%100
n / (i*10) + if(k < 10) 0 else if(k < 20) n % k - i + 1 else 10.
以上有很多else if语句，可以进一步简化原始，对于不足100的部分，1的个数限制于[0,i]，当10<k<20时，1的个数为n % k - i + 1，当k小于10，上式小于0，当k大于等于20，上式大于i，我们只需要将结果限制在[0,i]，因此可以简化为：
n / (i*10) + min(max(n % k - i + 1, 0), i)

- 百位，i=100
每1000个数，百位就出现100个1，n / (i*10) * i。不足1000，末尾<100就没有1，大于等于100且小于200，如199，就有199-99个1，大于等于200，就有100个1.与十位的计算方法相同，可以得到公式：
n / (i*10) + min(max(n % k - i + 1, 0), i)

到这里我们就抽象出了所有的规律，写成代码即可
'''
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        num_1 = 0
        i = 1
        while int(n / i) != 0:
            num_1 += int(n / (i*10)) * i
            num_1 += min(max(n % (i*10) - i + 1, 0), i)
            i *= 10
        return num_1
        
        # def count_1(n):
        #     count = 0
        #     while n >= 10:
        #         if n%10 == 1:
        #             count += 1
        #         n = int(n/10)
        #     if n == 1:
        #         count += 1
        #     return count
        
        # num_1 = 0
        # for i in range(n):
        #     num_1 += count_1(i+1)
        # return num_1