# -*- coding:utf-8 -*-
'''
@题目描述
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

@解题思路
我本来的思路是判断每个数是不是丑数，然后找到第N个，但是超时了，看了讨论区的答案，很受启发，其实可以逐个计算出丑数。考虑一下，我们手动计算丑数的过程也不是一个个数依次去判断是不是丑数，而是逐个相乘找最小的数。

如2*(2，3，5)=(4,6,10)
3*(2,3,5)=(6,9,15)
每一个丑数都要*(2,3,5)作为之后的丑数，我们要做的是如何从小到大找到这些丑数。

用三个指针分别指向三个丑数，并从这三个丑数*2，*3，*5中选取最小值，作为当前的丑数。
我们用t2,t3,t5,表示三个丑数，初始化都为0，表示都指向第一个丑数.
res=[1]用于存储丑数
res[t2] * 2 = 2
res[t3] * 3 = 3
res[t5] * 5 = 5
因此最小的为2，存入res，此时res=[1,2]，t2 = t2+1 因为res[0]已经乘过2了，下一个要乘2的应该是res[1]。循环查找最小值。

以上过程的原则就是，每一个丑数乘2,3,5都还是丑数，因此我们需要从小到大地找到这些丑数。

看代码思路会更清晰一些
'''
class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index < 7: #可以发现前6个丑数就是1,2,3,4,5,6，因此可以直接返回
            return index
        #res用于存丑数，第一个为1
        res = []
        res.append(1)
        t2, t3, t5 = 0, 0, 0 # 三个指针初始化为0，指向第一个丑数
        #循环index-1次，找到index个丑数
        for i in range(index - 1):
            min_ = min(res[t2]*2, res[t3]*3, res[t5]*5)
            t2 = t2 + 1 if min_ == res[t2]*2 else t2
            t3 = t3 + 1 if min_ == res[t3]*3 else t3
            t5 = t5 + 1 if min_ == res[t5]*5 else t5
            res.append(min_)
        return res[-1]