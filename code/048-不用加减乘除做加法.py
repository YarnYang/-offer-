# -*- coding:utf-8 -*-
'''
@题目描述
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

@解题思路
由于不能使用+ - * /，因此考虑用位运算，思考计算机内部是如何计算的。
例：
3+5
bin(3) = 0011
bin(5) = 0101

正确答案：bin(3)+bin(5) = 1000
计算步骤：
由于在位运算中：
1+1=10，进位为1，保留位为0
1+0=1，进位为0，保留1
0+0=0，进位为0，保留0
因此进位我们可以用&与来表示，即只有都是1的时候才有进位，注意进位得到的数应该加到上一位，因此使用<<进行左移；保留下来的用异或来表示，即只有一个1一个0才=1，00和11都是0.
用xor表示异或结果，carry记录进位结果，重新回到上述例子中：
xor = 0011 ^ 0101 = 0110
carry = 0011 & 0101 << 1 = 0001 << 1 = 0010
重复
xor = 0110 ^ 0010 = 0100
carry = 0110 & 0010 << 1 = 0100
重复
xor = 0100 ^ 0100 = 0000
carry = 0100 & 0100 << 1 = 1000
重复x
xor = 0000 ^ 1000 = 1000
carry = 0000 & 1000 << 1 = 0000
此时carry为0，跳出循环，输出xor的值

同样需要注意python中负数的补码表示，要用&0xffffffff得到负数的补码表示。
以-4为例，-4的补码表示为bin(4294967292) = 11111111111111111111111111111100，但是由于python的整数没有长度限制，因此python会把4294967292当成是正数直接输出，我们要做的就是与0xffffffff相与，将长度限制在32位中，告诉python这是一个负数。
'''
class Solution:
    def Add(self, num1, num2):
        # write code here
        carry = 1 #进位，初始化为1是为了可以进入while循环
        xor = 0
        while carry:    
            xor = (num1 ^ num2) & 0xffffffff
            carry = ((num1 & num2) << 1) & 0xffffffff
            num1, num2 = xor, carry
        if xor <= 0x7fffffff:
            return xor
        else:
            return ~(xor ^ 0xffffffff)
        # 解析参考https://blog.csdn.net/lrs1353281004/article/details/87192205